---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---
# React 中基本知识
## 组件 & Props
- 可以将UI切分成一些独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件
- 组件从概念上类似于JavaScript函数。它接受任意的入参，并返回用于描述页面展示内容的React元素。
### 函数组件
- 函数组件接收一个单一的`props`对象并返回了一个React元素
```js
function Welcome(props){
  return <h1>Hello, {props.name}</h1>
}
```
### 类组件
```js
class Welcome extends React.Component {
  render(){
    return <h1>Hello, {this.props.name}</h1>
  }
}
```
### 组件渲染
- React元素不但可以是DOM标签，还可以是用户自定义的组件
- 当React元素为用户自定义组件时，它会将JSX所接收的属性转换为单个对象传递给组件，这个对象被称为`props`
- 组件名称必须以大写字母开头
- 组件必须在使用的时候定义或引用它
- 组件的返回值只能有一个根元素
```js
class Panel extends Component {
  render (){
    let { header ,body} = this.props
    return (
      <div className="container">
        <div className="panel-default panel">
          <Header header={header}></Header>
          <Body body={body}/>
        </div>
      </.div>
    )
  }
}
class Body extends Component {
  render(){
    return <div className="panel-body">{this.props.body}</div>
  }
}
class Header extends Component {
  render(){
    return <div classNmae="panel-heading"><this.props.header></div>
  }
}
let data= {
  header:'123',
  body: '456'
}
ReactDom.render(<Panel {...data}/>,window.root)
```
### props的只读性
- 无论是使用函数或是类来声明的一个组件，它决不能修改它自己的 `props`
- `纯函数`没有改变它自己的输入值，当传入的值相同时，总是返回相同的结果
- 所有的React组件必须像纯函数那样使用他它们的props
```js
// 纯函数
function sum(a,b){
  return a + b
}
// 非纯函数
function withdraw (account,amount){
  account.total -= amount
}
```
### 进行类型检查
- 要在组件的props上进行类型检查，你只需要配置特定的propsTypes属性
- 你可以通过配置特定的defaultProps属性来定义props的默认值
```js
import PropsTypes from 'prop-types'
MyComponent.propTypes = {
  // 你可以将属性声明为js原生类型，默认情况下 这些属性都是可选的
  optionalArray: PropTypes.array,
  optionalBool:PropTypes.bool,
  optionalFunc:PropTyeps.number,
  potionalNumber:PropTypes.object,
  optionalObject:PropTypes.string,
  optionalSymbol:PropTypes.symbol,
  // 任何可被渲染的元素（包含数字，字符串、元素或数组或Fragment）也包含这些类型
  optionalNode:PropTypes.node,
  // 一个React元素
  optionalElement:PropTypes.element,
  // 你也可以声明prop为类的实例，这里使用js的instanceof操作符
  optionalMessage:PropTypes.instancOf(Message),
  //你可以让你的prop只能是特定的值，指定它为枚举类型
  optionalEnum:PropTypes.oneOf(['News','Photos'])
  //一个对象可以是几种类型中的任意一个类型
  optionalUnion:PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message)
  ]),
  //可以指定一个数组由某一类型的元素组成
  optionalArrayOf:PropTypes.arrayOf(PropTypes.number),
  //可以指定一个对象由某一类型的值组成
  optionalObjectOf:PropsTypes.objectOf(PropTypes.number),
  //可以指定一个对象由特定的类型值组成
  optionalObjectWithShape:PropTypes.shape({
    color:PropTypes.string,
    fontSize:PropTyeps.number
  })
  // 你可以在任何PropTypes属性后面加上`isRequired`,确保这个prop没有被提供时，会打印警告信息
  requiredFunc:PropTypes.func.isRequired,
  //任意类型的数据
  requiredAny:PropTypes.any.isRequired,
  //你可以指定一个自定义验证器。它在验证失败时应返回一个Error对象；请不要使用`console.warn`或抛出异常，因为这在`oneOfType`中不会起作用
  customProp:function(props,propName,componentName){
    if(!/matchme/.test(props[propName])){
      return new Error(
        'Invalid prop`'+propName+'`supplied to'+'`'+componentName+'`. Validation failed .'
      )
    }
  },
  // 你也可以提供一个自定以的`arrayOf` 或`objectOf`验证器；它应该在验证失败时返回一个Error对象；验证器将验证数组对象中的每个值。验证器的前两个参数；第一个是数组或对象本身，第二个是他们当前的键
  customArrayProp: PropTypes.arrayOf(function(propValue,keyi,componentName,location,propFullName)){
    if(!/matchme/.test(propValue[key])){
      return new Error(
        'Invalid prop`'+propName+'`supplied to'+'`'+componentName+'`. Validation failed .'
      )
    }
  }
}
```
```js
import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'
class Person extends React.Component {
  static defaultProps = {
    name: 'Stranger'
  }
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number.isRequired,
    gender: PropTypes.oneOf(['male','famale']),
    hobby:PropTypes.array,
    postion: PropTypes.shape({
      x:PropTypes.number,
      y:PropTypes.number
    })
  }
  render(){
    let {name,age,gender,hobby,position} = this.props
    return (
      <table>
        <thead>
          <tr>
            <td>姓名</td>
            <td>年龄</td>
            <td>性别</td>
            <td>爱好</td>
            <td>位置</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>{name}</td>
            <td>{age}</td>
            <td>{gender}</td>
            <td>{hobby.join(',')}</td>
            <td>{position.x+' ' + position.y}</td>
          </tr>
        </tbody>
      </table>
    )
  }
}
let person={
  age:100,
  gender:'male',
  hobby:['basketball','football'],
  position: {x:10,y:10}
}
ReactDOM.render(<Person {...person}/>,document.getElementById('root'))
```