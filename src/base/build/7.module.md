---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---
# React 中基本知识
## 组件 & Props
- 可以将UI切分成一些独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件
- 组件从概念上类似于JavaScript函数。它接受任意的入参，并返回用于描述页面展示内容的React元素。
### 函数组件
- 函数组件接收一个单一的`props`对象并返回了一个React元素
```js
function Welcome(props){
  return <h1>Hello, {props.name}</h1>
}
```
### 类组件
```js
class Welcome extends React.Component {
  render(){
    return <h1>Hello, {this.props.name}</h1>
  }
}
```
### 组件渲染
- React元素不但可以是DOM标签，还可以是用户自定义的组件
- 当React元素为用户自定义组件时，它会将JSX所接收的属性转换为单个对象传递给组件，这个对象被称为`props`
- 组件名称必须以大写字母开头
- 组件必须在使用的时候定义或引用它
- 组件的返回值只能有一个根元素
```js
class Panel extends Component {
  render (){
    let { header ,body} = this.props
    return (
      <div className="container">
        <div className="panel-default panel">
          <Header header={header}></Header>
          <Body body={body}/>
        </div>
      </.div>
    )
  }
}
class Body extends Component {
  render(){
    return <div className="panel-body">{this.props.body}</div>
  }
}
class Header extends Component {
  render(){
    return <div classNmae="panel-heading"><this.props.header></div>
  }
}
let data= {
  header:'123',
  body: '456'
}
ReactDom.render(<Panel {...data}/>,window.root)
```
### props的只读性
- 无论是使用函数或是类来声明的一个组件，它决不能修改它自己的 `props`
- `纯函数`没有改变它自己的输入值，当传入的值相同时，总是返回相同的结果
- 所有的React组件必须像纯函数那样使用他它们的props
```js
// 纯函数
function sum(a,b){
  return a + b
}
// 非纯函数
function withdraw (account,amount){
  account.total -= amount
}
```
### 进行类型检查
- 要在组件的props上进行类型检查，你只需要配置特定的propsTypes属性
- 你可以通过配置特定的defaultProps属性来定义props的默认值
```js
import PropsTypes from 'prop-types'
MyComponent.propTypes = {
  // 你可以将属性声明为js原生类型，默认情况下 这些属性都是可选的
  optionalArray: PropTypes.array,
  optionalBool:PropTypes.bool,
  optionalFunc:PropTyeps.number,
  potionalNumber:PropTypes.object,
  optionalObject:PropTypes.string,
  optionalSymbol:PropTypes.symbol,
  // 任何可被渲染的元素（包含数字，字符串、元素或数组或Fragment）也包含这些类型
  optionalNode:PropTypes.node,
  // 一个React元素
  optionalElement:PropTypes.element,
  // 你也可以声明prop为类的实例，这里使用js的instanceof操作符
  optionalMessage:PropTypes.instancOf(Message),
  //你可以让你的prop只能是特定的值，指定它为枚举类型
  optionalEnum:PropTypes.oneOf(['News','Photos'])
  //一个对象可以是几种类型中的任意一个类型
  optionalUnion:PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.instanceOf(Message)
  ]),
  //可以指定一个数组由某一类型的元素组成
  optionalArrayOf:PropTypes.arrayOf(PropTypes.number),
  //可以指定一个对象由某一类型的值组成
  optionalObjectOf:PropsTypes.objectOf(PropTypes.number),
  //可以指定一个对象由特定的类型值组成
  optionalObjectWithShape:PropTypes.shape({
    color:PropTypes.string,
    fontSize:PropTyeps.number
  })
  // 你可以在任何PropTypes属性后面加上`isRequired`,确保这个prop没有被提供时，会打印警告信息
  requiredFunc:PropTypes.func.isRequired,
  //任意类型的数据
  requiredAny:PropTypes.any.isRequired,
  //你可以指定一个自定义验证器。它在验证失败时应返回一个Error对象；请不要使用`console.warn`或抛出异常，因为这在`oneOfType`中不会起作用
  customProp:function(props,propName,componentName){
    if(!/matchme/.test(props[propName])){
      return new Error(
        'Invalid prop`'+propName+'`supplied to'+'`'+componentName+'`. Validation failed .'
      )
    }
  },
  // 你也可以提供一个自定以的`arrayOf` 或`objectOf`验证器；它应该在验证失败时返回一个Error对象；验证器将验证数组对象中的每个值。验证器的前两个参数；第一个是数组或对象本身，第二个是他们当前的键
  customArrayProp: PropTypes.arrayOf(function(propValue,keyi,componentName,location,propFullName)){
    if(!/matchme/.test(propValue[key])){
      return new Error(
        'Invalid prop`'+propName+'`supplied to'+'`'+componentName+'`. Validation failed .'
      )
    }
  }
}
```
```js
import React from 'react'
import ReactDOM from 'react-dom'
import PropTypes from 'prop-types'
class Person extends React.Component {
  static defaultProps = {
    name: 'Stranger'
  }
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number.isRequired,
    gender: PropTypes.oneOf(['male','famale']),
    hobby:PropTypes.array,
    postion: PropTypes.shape({
      x:PropTypes.number,
      y:PropTypes.number
    })
  }
  render(){
    let {name,age,gender,hobby,position} = this.props
    return (
      <table>
        <thead>
          <tr>
            <td>姓名</td>
            <td>年龄</td>
            <td>性别</td>
            <td>爱好</td>
            <td>位置</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>{name}</td>
            <td>{age}</td>
            <td>{gender}</td>
            <td>{hobby.join(',')}</td>
            <td>{position.x+' ' + position.y}</td>
          </tr>
        </tbody>
      </table>
    )
  }
}
let person={
  age:100,
  gender:'male',
  hobby:['basketball','football'],
  position: {x:10,y:10}
}
ReactDOM.render(<Person {...person}/>,document.getElementById('root'))
```
### 虚拟DOM
#### index.js
```js
import React from './react'
import ReactDOM from './react-dom'

class Welcome extends React.Component {
  render(){
    return React.createElement('h1',{className:'title'},this.props.title)
  }
}
let element = React.createElement(Welcome,{title:'标题'})
ReactDOM.render(element,document.getElementById('root'))
```
### react.js
```js
import createElement from './element'
class Component {
  static isReactComponent = true
  constructor(props){
    this.props = props
  }
}
export default {
  createElement,Component
}
```
#### element.js
```js
const ReactElement = function(type,props){
  const element = {
    type: type,
    props: props
  }
  return element
}
function createElement(type,config,children){
  let propName
  const props = {}
  for(propName in config){
    props[propName] = config[propName]
  }
  const childrenLength = arguments.length - 2
  if(childrenLength === 1){
    props.children = children
  }else if(childrenLength > 1){
    props.children = Array.prototype.slice.call(arguments,2)
  }
  return ReactElement(type,props)
}
export default createElement
```
#### react-dom.js
```js
function render(element,container){
  if(typeof element == 'string'){
    return container.appendChild(document.createTextNode(element))
  }
  let type,props
  type = element.type
  props = element.props
  if(type.isReactComponent){
    element = new type(props).render()
    type = element.type
    props = element.props
  }
  let domElement = document.createElement(type)
  for(let propName in props) {
    if(propName === 'children'){
      let children = props[propName]
      children = Array.isArray(children)?children:[children]
      children.forEach(child => render(child,domElement))
    }else if(propName === 'style'){
      let styleObj = props[propName]
      let cssText = Object.keys(styleObj).map(attr => {
        return `${attr.replace(/[A-Z]/g,function(){
          return "-"+arguments[1]
        })}:${styleObj[attr]}`
      }).join(';')
      domElement.style.cssText = cssText
    }else {
      domElement.setAttribute(propName,props[propName])
    }
    container.appendChild(domElement)
  }
}
export default {render}
```
## 状态
- 组件的数据来源有两个地方，分别是属性对象和状态对象
- 属性是父组件传递过来的（默认属性，属性校验）
- 状态是自己内部的，改变状态唯一的方式就是`setState`
- 属性和状态的变化都会影响视图更新
```js
import React from 'react'
import ReactDOM from 'react-dom'
class Clock extends React.Component {
  constructor(props){
    super(props){
      this.state = {
        date: new Date()
      }
    }

    componentDidMount(){
      this.timerID = setInterval(
        () => this.tick(),
        1000
      )
    }

    componentWillUnmount(){
      clearInterval(this.timerID)
    }

    tick(){
      this.setState({
        date: new Date()
      })
    }

    render(){
      return (
        <div>
          <h1> Hello, word!</h1>
          <h2>It is { this.state.date.toLocaleTimeString()}</h2>
        </div>
      )
    }
  }
}
ReactDOM.render(
  <Clock>,
  document.getElementById('root')
)
```
### 不要直接修改State
- 构造函数是唯一可以给`this.state`赋值的地方
```js
import React from 'react'
import ReactDOM from 'react-dom'
class Counter extends React.Component {
  constructor(props){
    super(props){
      this.state = {
        number: 0
      }
    }
  }

  componentDidMount(){
    this.timerID = setInterval(
      () => {
        this.state.number = this.state.number + 1
      },
      1000
    )
  }

  componentWillUnmount(){
    clearInterval(this.timerID)
  }

  render(){
    return (
      <div>
        <p>{this.state.number}</p>
      </div>
    )
  }
}

ReactDOM.render(
  <Counter />,
  document.getElementById('root')
)
```
### State的更新可能是异步的
- 出于性能考虑，React可能会把多个setState()调用合并成一个调用
- 因为this.props和this.state可能会异步更新，所以你不要依赖他们的值来更新下一个状态
- 可以让setState()接收一个函数而不是一个对象。这个函数用上一个state作为第一个参数
```js
import React from 'react'
import ReactDOM from 'react-dom'
class Counter extends React.Component {
  constructor(props){
    super(props)
    this.state = {
      number: 0
    }
  }

  handleClick = () => {
    this.setState((state)=>(
      {number:state.number+1}
    ))
    this.setState((state)=>(
      {number: state.number+1}
    ))
  }

  render(){
    return (
      <div>
        <p>{this.state.number}</p>
        <button onClick={this.handleClick}>+</button>
      </div>
    )
  }
}
ReactDOM.render(
  <Counter />,
  document.getElementById('root')
)
```
### State 的更新会被合并
- 当你调用setState()的时候，React会把你提供的对象合并到当前的state
```js
import React from 'react'
import ReactDOM from 'react-dom'
class Counter extends React.Component {
  constructor(props){
    super(props)
    this.state = {
      name: 'zhufeng',
      number: 0
    }
  }
  handleClick = () =>{
    this.setState(state =>(
      {number: state.number+1}
    ))
    this.setState(state =>(
      {numbner: state.number+1}
    ))
  }
  render(){
    return (
      <div>
        <p>{this.state.name}:{this.state.number}</p>
        <button onClick={this.handleClick}>+</button>
      </div>
    )
  }
}
ReactDOM.render(
  <Counter/>,
  document.getElementById('root')
)
```
### 数据是向下流动的
- 不管是父组件或是自组件都无法知道某个组件是有状态还是无状态，并且它们也并不关心它是函数组件还是class组件
- 这就是为什么称state为局部的或是封装的原因，除了拥有并设置了它的组件，其他组件都无法访问
- 任何state总是所属于特定的组件，而且从该state派生的任何数据或UI只能影响树中“低于”它的组件
- 如果你把一个以组件构成的树想象成一个props的数据瀑布的话，那么每个组件的state就像在任意一点上给瀑布增加额外的水源，但是它只能向下流动
```js
import React from 'react'
import ReactDOM from 'react-dom'
class Counter extends React.Component{
  constructor(props){
    super(props)
    this.state= {
      number: 90
    }
  }
  handleClick(()=>{
    this.setState(state=>(
      {number:state.number+1}
    ))
  })
  render(){
    return (
      <div style={{border:'1px solid red'}}>
        <p>{this.state.name}:{this.state.number}</p>
        <button onClick={this.handleClick}>+</button>
        <SubCounter number={this.state.number} />
      </div>
    )
  }
}
class SubCounter extends React.Component {
  render(){
    return <div style={{border:'1px solid blue'}}>子计数器：{this.props.number}</div>
  }
}
ReactDOM.render(
  <Counter />,
  document.getElementById('root')
)
```
## 事件处理
- React事件的命名采用小驼峰式，而不是纯小写
- 使用JSX语法时你需要传入一个函数作为事件处理函数，而不是一个字符串
- 你不能通过返回 `false`方式阻止默认行为，你必须显式使用`preventDefault`
```js
import React from 'react'
import ReactDOM from 'react-dom'
class Link extends React.Component {
  handleClick(e){
    e.preventDefault()
    console.log('The link was clicked .')
  }
  render(){
    return (
      <a href="http://www.baidu.com" onClick={this.handleClick}>
        Click me
      </a>
    )
  }
}
ReactDOM.render(
  <Link />,
  document.getElementById('root')
)
```
### this
- 你必须谨慎对待JSX回调函数中的this, 可以使用
  - 公共属性（箭头函数）
  - 匿名函数
  - bind进行绑定
```js
class LoggingButton extends React.Component {
  handleClick(){
    console.log('this is:', this)
  }
  handleClcik1=()=>{
    console.log('this is:',this)
  }
  render(){
    return (
      <button onClick={event => this.handleClick(event)}>Click me</button>
    )
  }
}
```
### 向事件处理程序传递参数
- 匿名函数
- bind
```js
class LoggingButton extends React.Component {
  handleClick = (id, event) =>{
    console.log('id',id)
  }
  render(){
    return (
      <>
        <button onClick={event=>this.handleClick('1',event)}>Click me</button>
        <button onClick={this.handleClick.bind(this,'1')}>Click me</button>
      </> 
    )
  }
}
```
### Ref
- Refs提供了一种方式，允许我们访问dom节点或在render方法中创建的React元素
- 在React渲染生命周期时，表单元素上的value将会覆盖DOM节点中的值，在非受控组件中，你经常希望　React 能赋予组件一个初始值，但是不去控制后续的更新。在这种情况下，你可以指定一个defaultValue属性，而不是value.
